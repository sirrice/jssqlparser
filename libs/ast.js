// Generated by CoffeeScript 1.10.0
(function() {
  var BetweenExpr, ColExpr, DEBUG, Expr, ExternalTable, From, FuncExpr, FunctionQuery, Group, Having, LetUDF, LetUDFArg, Limit, Node, OrderBy, OrderByClause, Project, ProjectClause, QuantExpr, Queries, Query, QueryTable, SelectCore, SpecialExpr, Table, TableExpr, TableUDF, UnaryExpr, ValExpr, Where, _, schema,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require("underscore");

  _.append = function(arr, v) {
    arr = _.clone(arr);
    arr.push(v);
    return arr;
  };

  DEBUG = false;

  Node = (function() {
    Node.id = 1;

    function Node(type1) {
      this.type = type1;
      this.id = Node.id++;
    }

    Node.prototype.isType = function() {
      var ref;
      return ref = this.nodeType(), indexOf.call(arguments, ref) >= 0;
    };

    Node.prototype.isExpr = function() {
      var ref;
      return (ref = this.nodeType()) === "Expr" || ref === "SpecialExpr" || ref === "ColExpr" || ref === "ValExpr" || ref === "BetweenExpr" || ref === "UnaryExpr" || ref === "FuncExpr" || ref === "TableExpr";
    };

    Node.prototype.isTable = function() {
      var ref;
      return (ref = this.nodeType()) === "Table" || ref === "QueryTable";
    };

    Node.prototype.clone = function() {
      throw Error("not implemented");
    };

    Node.prototype.nodeType = function() {
      return this.constructor.name;
    };

    Node.prototype.descendents = function() {
      var f, ret, types;
      types = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ret = [];
      f = function(node, path) {
        if (node.isType.apply(node, types)) {
          return ret.push(node);
        }
      };
      this.traverse(f);
      return ret;
    };

    Node.prototype.children = function() {
      return [];
    };

    Node.prototype.sources = function() {
      return this.descendents("Table");
    };

    Node.prototype.variables = function() {
      return this.descendents("ColExpr");
    };

    Node.prototype.allNodes = function(f) {
      var func, ret;
      ret = [];
      func = function(node, path) {
        if (f(node)) {
          return ret.push(node);
        }
      };
      this.traverse(func);
      return _.uniq(ret);
    };

    Node.prototype.traverse = function(f, path) {
      var child, i, len, newpath, ref, results;
      if (path == null) {
        path = [];
      }
      f(this, path);
      newpath = _.append(path, this);
      ref = this.children();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        if (child == null) {
          continue;
        }
        if (!_.isFunction(child.traverse)) {
          console.log(child);
        }
        results.push(child.traverse(f, newpath));
      }
      return results;
    };

    Node.prototype.toSQL = function() {
      return "";
    };

    Node.prototype.toPrettySQL = function() {
      return this.toSQL();
    };

    Node.prototype.toString = function() {
      return this.toSQL();
    };

    Node.prototype.toJSString = function() {
      throw new Error("toJSString() not implemented by " + (this.toSQL()));
    };

    Node.prototype.toDot = function() {
      var f, output, s;
      output = [];
      output.push("\ndigraph DepGraph" + this.nprintcalls + " {");
      output.push("  labelloc=\"t\";");
      output.push("  label=\"graph" + this.nprintcalls + "\";");
      f = function(node, path) {
        var name, parent, pname;
        if (path.length > 0) {
          parent = _.last(path);
          pname = parent.nodeType();
          name = node.nodeType();
          return output.push("  " + pname + parent.id + " -> " + name + node.id);
        }
      };
      this.traverse(f);
      output.push("}\n");
      s = output.join("\n");
      return s;
    };

    return Node;

  })();

  Queries = (function(superClass) {
    extend(Queries, superClass);

    function Queries(queries) {
      this.queries = queries;
      Queries.__super__.constructor.apply(this, arguments);
    }

    Queries.prototype.clone = function() {
      return new Queries(_.map(this.queries, function(q) {
        return q.clone();
      }));
    };

    Queries.prototype.children = function() {
      return this.queries;
    };

    Queries.prototype.toSQL = function() {
      var sqls;
      sqls = _.map(this.queries, function(q) {
        return q.toSQL();
      });
      return (sqls.join(";")) + ";";
    };

    Queries.prototype.toPrettySQL = function() {
      var sqls;
      sqls = _.map(this.queries, function(q) {
        return q.toSQL();
      });
      return (sqls.join(";\n")) + ";";
    };

    return Queries;

  })(Node);

  SelectCore = (function(superClass) {
    extend(SelectCore, superClass);

    function SelectCore(project1, from1, where1, groupby1) {
      this.project = project1 != null ? project1 : null;
      this.from = from1 != null ? from1 : null;
      this.where = where1 != null ? where1 : null;
      this.groupby = groupby1 != null ? groupby1 : null;
      if (this.where == null) {
        this.where = new Where;
      }
      SelectCore.__super__.constructor.apply(this, arguments);
    }

    SelectCore.prototype.clone = function() {
      var from, groupby, limit, orderby, project, set, where;
      project = from = where = set = groupby = limit = orderby = null;
      if (this.project != null) {
        project = this.project.clone();
      }
      if (this.from != null) {
        from = this.from.clone();
      }
      if (this.where != null) {
        where = this.where.clone();
      }
      if (this.groupby != null) {
        groupby = this.groupby.clone();
      }
      return new SelectCore(project, from, where, groupby, orderby, limit);
    };

    SelectCore.prototype.children = function() {
      return _.compact([this.project, this.from, this.where, this.groupby, this.orderby, this.limit]);
    };

    SelectCore.prototype.toSQL = function() {
      var ret;
      ret = ["SELECT " + (this.project.toSQL())];
      if ((this.from != null) && (this.from.tables != null) && this.from.tables.length > 0) {
        ret.push("FROM " + (this.from.toSQL()));
      }
      if (this.where != null) {
        ret.push("WHERE " + (this.where.toSQL()));
      }
      if (this.groupby != null) {
        ret.push(" GROUP BY " + (this.groupby.toSQL()));
      }
      return ret.join(" ");
    };

    SelectCore.prototype.schema = function() {
      return this.project.schema();
    };

    return SelectCore;

  })(Node);

  Query = (function(superClass) {
    extend(Query, superClass);

    function Query(type1, selectCores, orderby1, limit1) {
      this.type = type1;
      this.selectCores = selectCores != null ? selectCores : [];
      this.orderby = orderby1 != null ? orderby1 : null;
      this.limit = limit1 != null ? limit1 : null;
      this.selectCores = _.compact(_.flatten([this.selectCores]));
      Query.__super__.constructor.apply(this, arguments);
      this.set = null;
    }

    Query.prototype.clone = function() {
      var cores, limit, orderby;
      cores = this.selectCores.map(function(sc) {
        return sc.clone();
      });
      if (this.orderby != null) {
        orderby = this.orderby.clone();
      }
      if (this.limit != null) {
        limit = this.limit.clone();
      }
      return new Query(this.type, cores, orderby, limit);
    };

    Query.prototype.children = function() {
      return _.union(this.selectCores, _.compact([this.orderby, this.limit]));
    };

    Query.prototype.toSQL = function() {
      var cores, ret;
      cores = this.selectCores.map(function(sc) {
        return sc.toSQL();
      });
      ret = [cores.join(" UNION ")];
      if (this.orderby != null) {
        ret.push(" ORDER BY " + (this.orderby.toSQL()));
      }
      if (this.limit != null) {
        ret.push(" LIMIT " + (this.limit.toSQL()));
      }
      return ret.join(" ");
    };

    Query.prototype.schema = function() {
      var core, i, isConsistent, len, ref, schema;
      schema = null;
      ref = this.selectCores;
      for (i = 0, len = ref.length; i < len; i++) {
        core = ref[i];
        if (schema != null) {
          isConsistent = _.chain(schema).zip(core.schema()).all(function(pair) {
            return pair[0].type === pair[1].type;
          }).value();
          if (!isConsistent) {
            throw new Error("Inconsistent schemas: " + (JSON.stringify(schema)) + " ::: " + (JSON.stringify(core.schema())));
          }
        } else {
          schema = core.schema();
        }
      }
      if (schema == null) {
        schema = [];
      }
      return schema;
    };

    return Query;

  })(Node);

  Project = (function(superClass) {
    extend(Project, superClass);

    function Project(clauses1) {
      this.clauses = clauses1;
      this.clauses = _.compact(_.flatten([this.clauses]));
      Project.__super__.constructor.apply(this, arguments);
    }

    Project.prototype.canonicalize = function() {
      return _.each(this.clauses, function(clause, idx) {
        if (clause.alias == null) {
          return clause.alias = "col_" + idx;
        }
      });
    };

    Project.prototype.addClause = function(clause) {
      return this.clauses.push(clause);
    };

    Project.prototype.getByAlias = function(aliasOrIdx) {
      var c, i, len, ref;
      if (_.isNumber(aliasOrIdx)) {
        return this.clauses[aliasOrIdx];
      } else {
        ref = this.clauses;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c.alias === aliasOrIdx) {
            return c;
          }
        }
      }
    };

    Project.prototype.clone = function() {
      var clauses;
      clauses = _.compact(_.map(this.clauses, function(c) {
        if (c != null) {
          return c.clone();
        }
      }));
      return new Project(clauses);
    };

    Project.prototype.children = function() {
      return this.clauses;
    };

    Project.prototype.toSQL = function() {
      var sqls;
      sqls = _.compact(_.map(this.clauses, function(clause) {
        if (clause != null) {
          return clause.toSQL();
        }
      }));
      return sqls.join(", ");
    };

    Project.prototype.schema = function(tableAliases) {
      var aliasIdx, clause, i, len, ref, results;
      ref = this.clauses;
      results = [];
      for (aliasIdx = i = 0, len = ref.length; i < len; aliasIdx = ++i) {
        clause = ref[aliasIdx];
        if (clause.expr.isType("SpecialExpr")) {
          results.push({
            alias: null,
            tableName: clause.expr.table.name,
            type: "star"
          });
        } else {
          if (clause.alias == null) {
            clause.alias = "col" + aliasIdx;
          }
          results.push({
            alias: clause.alias,
            type: clause.exprType()
          });
        }
      }
      return results;
    };

    return Project;

  })(Node);

  ProjectClause = (function(superClass) {
    extend(ProjectClause, superClass);

    function ProjectClause(expr1, alias) {
      this.expr = expr1;
      this.alias = alias != null ? alias : null;
      if (this.expr.isType("ColExpr")) {
        if (this.alias == null) {
          this.alias = this.expr.col;
        }
      }
      ProjectClause.__super__.constructor.apply(this, arguments);
    }

    ProjectClause.prototype.clone = function() {
      var proj;
      proj = new ProjectClause(this.expr.clone(), this.alias);
      return proj;
    };

    ProjectClause.prototype.children = function() {
      return [this.expr];
    };

    ProjectClause.prototype.toSQL = function() {
      if (this.alias != null) {
        return (this.expr.toSQL()) + " AS " + this.alias;
      } else {
        return this.expr.toSQL();
      }
    };

    ProjectClause.prototype.exprType = function() {
      var f, type;
      type = null;
      f = function(node) {
        var ref;
        if (type != null) {
          return;
        }
        if (node.isType("Expr")) {
          if ((ref = node.op) === "+" || ref === "-" || ref === "/" || ref === "*") {
            return type = "numeric";
          }
        } else if (node.isType("ValExpr")) {
          if (_.isString(node.v)) {
            return type = "text";
          } else {
            return type = "numeric";
          }
        } else if (node.isType("FuncExpr")) {
          if (node.isSQLFunc) {
            return type = "numeric";
          }
        }
      };
      this.expr.traverse(f);
      if (this.alias === "id" && type === null) {
        type = "numeric";
      }
      if (type == null) {
        console.error("WARN: col " + this.alias + " couldn't infer type for " + (this.toSQL()) + ".  ");
        console.error("WARN: defaulting to int");
        type = "numeric";
      }
      return type;
    };

    return ProjectClause;

  })(Node);

  From = (function(superClass) {
    extend(From, superClass);

    function From(tables) {
      this.tables = tables;
      this.tables = _.compact(_.flatten([this.tables]));
      From.__super__.constructor.apply(this, arguments);
    }

    From.prototype.addTable = function(table) {
      return this.queries.push(table);
    };

    From.prototype.getByAlias = function(aliasOrIdx) {
      var i, len, ref, t;
      if (_.isNumber(aliasOrIdx)) {
        return this.tables[aliasOrIdx];
      } else {
        ref = this.tables;
        for (i = 0, len = ref.length; i < len; i++) {
          t = ref[i];
          if (t.alias === aliasOrIdx) {
            return t;
          }
        }
      }
    };

    From.prototype.clone = function() {
      return new From(_.map(this.tables, function(t) {
        return t.clone();
      }));
    };

    From.prototype.children = function() {
      return this.tables;
    };

    From.prototype.toSQL = function() {
      var sqls;
      sqls = _.map(this.tables, function(t) {
        if (t.alias != null) {
          return "(" + (t.toSQL()) + ") AS " + t.alias;
        } else {
          return "" + (t.toSQL());
        }
      });
      sqls = _.without(sqls, _.isEmpty);
      return sqls.join(", ");
    };

    return From;

  })(Node);

  Table = (function(superClass) {
    extend(Table, superClass);

    function Table(name1, alias) {
      this.name = name1;
      this.alias = alias != null ? alias : null;
      this.isDefaultAlias = false;
      if (this.alias == null) {
        if (this.alias == null) {
          this.alias = this.name;
        }
        this.isDefaultAlias = true;
      }
      Table.__super__.constructor.apply(this, arguments);
    }

    Table.prototype.clone = function() {
      return new Table(this.name, this.alias);
    };

    Table.prototype.isExternalTable = function() {
      return false;
    };

    Table.prototype.toString = function(printAlias) {
      if (printAlias == null) {
        printAlias = true;
      }
      return this.name;
    };

    Table.prototype.toSQL = function(printAlias) {
      if (printAlias == null) {
        printAlias = true;
      }
      return this.name;
    };

    return Table;

  })(Node);

  ExternalTable = (function(superClass) {
    extend(ExternalTable, superClass);

    function ExternalTable(interactionName, name1) {
      this.interactionName = interactionName;
      this.name = name1;
      ExternalTable.__super__.constructor.apply(this, arguments);
    }

    ExternalTable.prototype.clone = function() {
      return new ExternalTable(this.interactionName, this.name);
    };

    ExternalTable.prototype.isExternalTable = function() {
      return true;
    };

    ExternalTable.prototype.toString = function() {
      return this.toSQL();
    };

    ExternalTable.prototype.toSQL = function() {
      return this.interactionName + "." + this.name;
    };

    return ExternalTable;

  })(Node);

  QueryTable = (function(superClass) {
    extend(QueryTable, superClass);

    function QueryTable(query1, alias) {
      this.query = query1;
      this.alias = alias != null ? alias : null;
      if (this.alias == null) {
        throw new Error("subquery needs to have an alias!  " + this.query);
      }
      QueryTable.__super__.constructor.apply(this, arguments);
    }

    QueryTable.prototype.clone = function() {
      return new QueryTable(this.query.clone(), this.alias);
    };

    QueryTable.prototype.children = function() {
      return [this.query];
    };

    QueryTable.prototype.toSQL = function() {
      return this.query.toSQL();
    };

    return QueryTable;

  })(Node);

  TableUDF = (function(superClass) {
    extend(TableUDF, superClass);

    function TableUDF(fname, exprs1, alias) {
      var ref;
      this.fname = fname;
      this.exprs = exprs1;
      this.alias = alias != null ? alias : null;
      if (this.alias == null) {
        throw new Error("UDF in FROM clause needs to have an alias! " + this.fname);
      }
      if ((ref = this.fname) === "abs" || ref === "min" || ref === "max") {
        throw new Error("SQL func should not be in FROM clause");
      }
      this.type = "TableUDF";
      this.exprs = _.compact(_.flatten([this.exprs]));
      TableUDF.__super__.constructor.apply(this, arguments);
    }

    TableUDF.prototype.clone = function() {
      return new TableUDF(this.fname, _.map(this.exprs, function(e) {
        return e.clone();
      }), this.alias);
    };

    TableUDF.prototype.traverse = function(f, path) {
      var newpath;
      if (path == null) {
        path = [];
      }
      f(this, path);
      newpath = _.append(path, this);
      return _.each(this.exprs, function(e) {
        return e.traverse(f, newpath);
      });
    };

    TableUDF.prototype.toSQL = function() {
      var args;
      args = this.exprs.map(function(e) {
        return e.toSQL();
      }).join(",");
      return this.fname + "(" + args + ")";
    };

    TableUDF.prototype.toJSString = function() {
      var args, f;
      f = this.fname;
      args = this.exprs.map(function(e) {
        return e.toJSString();
      }).join(",");
      return f + "(" + args + ")";
    };

    return TableUDF;

  })(Node);

  LetUDF = (function(superClass) {
    extend(LetUDF, superClass);

    function LetUDF(fname, args1, input, render_or_compute, source) {
      this.fname = fname;
      this.args = args1;
      this.input = input;
      this.render_or_compute = render_or_compute;
      this.source = source;
      this.type = "LetUDF";
      this.args = _.compact(_.flatten([this.args]));
      LetUDF.__super__.constructor.apply(this, arguments);
    }

    LetUDF.prototype.clone = function() {
      return new LetUDF(this.fname, _.map(this.exprs, function(e) {
        return e.clone();
      }), this.alias);
    };

    LetUDF.prototype.traverse = function(f, path) {
      var arg, i, len, newpath, ref, results;
      if (path == null) {
        path = [];
      }
      f(this, path);
      newpath = _.append(path, this);
      ref = this.args;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        arg = ref[i];
        results.push(arg.traverse(f, newpath));
      }
      return results;
    };

    LetUDF.prototype.clone = function() {
      var args;
      args = this.args.map(function(arg) {
        return arg.clone();
      });
      return new LetUDF(this.fname, args, this.exists);
    };

    LetUDF.prototype.toSQL = function() {
      return "";
    };

    LetUDF.prototype.schema = function() {
      return this.args.map(function(arg) {
        return arg.schema();
      });
    };

    return LetUDF;

  })(Node);

  LetUDFArg = (function(superClass) {
    extend(LetUDFArg, superClass);

    function LetUDFArg(name1, type1) {
      this.name = name1;
      this.type = type1;
      LetUDFArg.__super__.constructor.apply(this, arguments);
    }

    LetUDFArg.prototype.clone = function() {
      return new LetUDFArg(this.name, this.type);
    };

    LetUDFArg.prototype.toSQL = function() {
      return this.name + " " + this.type;
    };

    LetUDFArg.prototype.schema = function() {
      return {
        alias: this.name,
        type: this.type
      };
    };

    return LetUDFArg;

  })(Node);

  Where = (function(superClass) {
    extend(Where, superClass);

    function Where(exprs1, conj) {
      this.exprs = exprs1;
      this.conj = conj != null ? conj : " AND ";
      this.exprs = _.compact(_.flatten([this.exprs]));
      Where.__super__.constructor.apply(this, arguments);
    }

    Where.prototype.addExpr = function(expr) {
      return this.exprs.push(expr);
    };

    Where.prototype.getByAlias = function(aliasOrIdx) {
      if (_.isNumber(aliasOrIdx)) {
        return this.tables[aliasOrIdx];
      }
      return null;
    };

    Where.prototype.clone = function() {
      var exprs;
      exprs = _.map(this.exprs, function(e) {
        return e.clone();
      });
      return new Where(exprs, this.con);
    };

    Where.prototype.children = function() {
      return this.exprs;
    };

    Where.prototype.toSQL = function() {
      var strs;
      if (this.exprs.length === 0) {
        return "1 = 1";
      } else {
        strs = _.compact(_.map(this.exprs, function(expr) {
          return expr.toSQL();
        }));
        return strs.join(" AND ");
      }
    };

    Where.prototype.toJSString = function() {
      var join, strs;
      if (this.exprs.length === 0) {
        return "true";
      } else {
        join = " && ";
        if (/OR/.test(this.conj)) {
          join = " || ";
        }
        strs = _.chain(this.exprs).map(function(expr) {
          return "(" + (expr.toJSString()) + ")";
        }).compact().value();
        return strs.join(" && ");
      }
    };

    return Where;

  })(Node);

  Expr = (function(superClass) {
    extend(Expr, superClass);

    function Expr(l1, op1, r1) {
      this.l = l1;
      this.op = op1 != null ? op1 : null;
      this.r = r1 != null ? r1 : null;
      Expr.__super__.constructor.apply(this, arguments);
    }

    Expr.prototype.clone = function() {
      var l, op, r;
      l = this.l.clone();
      op = this.op;
      r = null;
      if (this.r != null) {
        r = this.r.clone();
      }
      return new Expr(l, op, r);
    };

    Expr.prototype.children = function() {
      return _.compact([this.l, this.r]);
    };

    Expr.prototype.toSQL = function() {
      if (this.op != null) {
        return "(" + (this.l.toSQL()) + " " + this.op + " (" + (this.r.toSQL()) + "))";
      } else {
        return this.l.toSQL();
      }
    };

    Expr.prototype.toJSString = function() {
      var op;
      if (this.op != null) {
        op = this.op;
        if (op === "=") {
          op = "==";
        }
        if (op === "AND") {
          op = "&&";
        }
        return "(" + (this.l.toJSString()) + " " + op + " (" + (this.r.toJSString()) + "))";
      } else {
        return this.l.toJSString();
      }
    };

    return Expr;

  })(Node);

  SpecialExpr = (function(superClass) {
    extend(SpecialExpr, superClass);

    function SpecialExpr(v1, table1) {
      this.v = v1;
      this.table = table1 != null ? table1 : null;
      this.tableName = null;
      if (this.table != null) {
        this.tableName = this.table.name;
      }
      SpecialExpr.__super__.constructor.apply(this, arguments);
    }

    SpecialExpr.prototype.clone = function() {
      return new SpecialExpr(this.v, this.table);
    };

    SpecialExpr.prototype.toSQL = function() {
      var prefix;
      prefix = "";
      if (this.tableName != null) {
        prefix = this.tableName + ".";
      }
      return "" + prefix + this.v;
    };

    SpecialExpr.prototype.toJSString = function() {
      if (this.tableName != null) {
        return "" + this.tableName;
      } else {
        throw new Error("SpecialExpr doesn't support toJSString: " + this.v);
      }
    };

    return SpecialExpr;

  })(Expr);

  BetweenExpr = (function(superClass) {
    extend(BetweenExpr, superClass);

    function BetweenExpr(v1, op1, minv, maxv) {
      this.v = v1;
      this.op = op1;
      this.minv = minv;
      this.maxv = maxv;
      BetweenExpr.__super__.constructor.apply(this, arguments);
    }

    BetweenExpr.prototype.clone = function() {
      return new BetweenExpr(this.v, this.op, this.minv, this.maxv);
    };

    BetweenExpr.prototype.children = function() {
      return _.compact([this.v, this.minv, this.maxv]);
    };

    BetweenExpr.prototype.toSQL = function() {
      return (this.v.toSQL()) + " " + this.op + " " + (this.minv.toSQL()) + " AND " + (this.maxv.toSQL());
    };

    BetweenExpr.prototype.toJSString = function() {
      var ret;
      ret = ["(" + (this.v.toJSString()) + " >= " + (this.minv.toJSString()) + ")", "(" + (this.v.toJSString()) + " < " + (this.maxv.toJSString()) + ")"];
      ret = ret.join(" && ");
      if (this.op === "NOT BETWEEN") {
        ret = "!(" + ret + ")";
      }
      return ret;
    };

    return BetweenExpr;

  })(Expr);

  UnaryExpr = (function(superClass) {
    extend(UnaryExpr, superClass);

    function UnaryExpr(op1, expr1) {
      this.op = op1;
      this.expr = expr1;
      UnaryExpr.__super__.constructor.apply(this, arguments);
    }

    UnaryExpr.prototype.clone = function() {
      return new UnaryExpr(this.op, this.expr.clone());
    };

    UnaryExpr.prototype.children = function() {
      return [this.expr];
    };

    UnaryExpr.prototype.toSQL = function() {
      return this.op + " " + (this.expr.toSQL());
    };

    UnaryExpr.prototype.toJSString = function() {
      if (this.op === "NOT") {
        return "!(" + (this.expr.toJSString()) + ")";
      } else if (this.op === "NOT EXISTS") {
        return "!_.isEmpty(" + (this.expr.toJSString()) + ")";
      } else {
        return "" + this.op + (this.expr.toJSString());
      }
    };

    return UnaryExpr;

  })(Expr);

  QuantExpr = (function(superClass) {
    extend(QuantExpr, superClass);

    function QuantExpr(type1, name1, set1, suchthat) {
      this.type = type1;
      this.name = name1;
      this.set = set1;
      this.suchthat = suchthat;
      QuantExpr.__super__.constructor.apply(this, arguments);
    }

    QuantExpr.prototype.clone = function() {
      return new QuantExpr(this.type, this.name, this.set, this.suchthat.clone());
    };

    QuantExpr.prototype.children = function() {
      return [this.set, this.suchthat];
    };

    QuantExpr.prototype.toSQL = function() {
      var type;
      type = "FORALL";
      if (this.type === "exists") {
        type = "EXISTS";
      }
      return type + " " + this.name + " IN " + (this.set.toSQL()) + " (" + (this.suchthat.toSQL()) + ")";
    };

    QuantExpr.prototype.toJSString = function() {
      var func;
      func = (function() {
        switch (this.type) {
          case "all":
            return "all";
          case "exists":
            return "any";
        }
      }).call(this);
      return "_." + func + "(" + (this.set.toJSString()) + ", function(" + this.name + ") { return " + (this.suchthat.toJSString()) + "; });";
    };

    return QuantExpr;

  })(Expr);

  FuncExpr = (function(superClass) {
    extend(FuncExpr, superClass);

    function FuncExpr(fname, exprs1) {
      this.fname = fname;
      this.exprs = exprs1;
      this.exprs = _.compact(_.flatten([this.exprs]));
      FuncExpr.__super__.constructor.apply(this, arguments);
    }

    FuncExpr.prototype.children = function() {
      return this.exprs;
    };

    FuncExpr.prototype.clone = function() {
      return new FuncExpr(this.fname, _.map(this.exprs, function(e) {
        return e.clone();
      }));
    };

    FuncExpr.prototype.isSQLFunc = function() {
      var ref;
      return (ref = this.fname) === "abs" || ref === "max" || ref === "min";
    };

    FuncExpr.prototype.toSQL = function() {
      var args;
      args = this.exprs.map(function(e) {
        return e.toSQL();
      }).join(",");
      return this.fname + "(" + args + ")";
    };

    FuncExpr.prototype.toJSString = function() {
      var args, f;
      f = (function() {
        switch (this.fname) {
          case "abs":
            return "Math.abs";
          case "max":
            return "Math.max";
          case "min":
            return "Math.min";
          default:
            return this.fname;
        }
      }).call(this);
      args = this.exprs.map(function(e) {
        return e.toJSString();
      }).join(",");
      return f + "(" + args + ")";
    };

    return FuncExpr;

  })(Expr);

  ColExpr = (function(superClass) {
    extend(ColExpr, superClass);

    function ColExpr(col, table1) {
      this.col = col;
      this.table = table1 != null ? table1 : null;
      this.tableName = null;
      if (this.table != null) {
        this.tableName = this.table.name;
      }
      ColExpr.__super__.constructor.apply(this, arguments);
    }

    ColExpr.prototype.children = function() {
      return _.compact([this.table]);
    };

    ColExpr.prototype.clone = function() {
      return new ColExpr(this.col, this.table);
    };

    ColExpr.prototype.toSQL = function() {
      var prefix;
      prefix = "";
      if (this.tableName != null) {
        prefix = this.tableName + ".";
      }
      return "" + prefix + this.col;
    };

    ColExpr.prototype.toJSString = function() {
      return this.toSQL();
    };

    return ColExpr;

  })(Expr);

  TableExpr = (function(superClass) {
    extend(TableExpr, superClass);

    function TableExpr(table1) {
      this.table = table1;
      if (this.table == null) {
        throw new Error("TableExpr got null table");
      }
      this.tableName = null;
      if (this.table != null) {
        this.tableName = this.table.name;
      }
      TableExpr.__super__.constructor.apply(this, arguments);
    }

    TableExpr.prototype.clone = function() {
      return new TableExpr(this.table.clone());
    };

    TableExpr.prototype.toSQL = function() {
      return this.table.toSQL();
    };

    TableExpr.prototype.toJSString = function() {
      return this.tableName;
    };

    return TableExpr;

  })(Expr);

  ValExpr = (function(superClass) {
    extend(ValExpr, superClass);

    function ValExpr(v1) {
      this.v = v1;
      ValExpr.__super__.constructor.apply(this, arguments);
    }

    ValExpr.prototype.children = function() {
      return [];
    };

    ValExpr.prototype.clone = function() {
      return new ValExpr(this.v);
    };

    ValExpr.prototype.toSQL = function() {
      if (_.isString(this.v)) {
        return "'" + this.v + "'";
      }
      return "" + this.v;
    };

    ValExpr.prototype.toJSString = function() {
      return this.toSQL();
    };

    return ValExpr;

  })(Expr);

  Group = (function(superClass) {
    extend(Group, superClass);

    function Group(groupinglist, having1) {
      this.groupinglist = groupinglist;
      this.having = having1;
      Group.__super__.constructor.apply(this, arguments);
    }

    Group.prototype.clone = function() {
      var having;
      having = null;
      if (this.having != null) {
        having = this.having.clone();
      }
      return new Group(this.groupinglist.map(function(g) {
        return g.clone();
      }, having));
    };

    Group.prototype.children = function() {
      return _.union(this.groupinglist, _.compact([this.having]));
    };

    Group.prototype.toSQL = function() {
      var grouping;
      grouping = this.groupinglist.map(function(g) {
        return g.toSQL();
      });
      if (this.having != null) {
        return (grouping.join(", ")) + " HAVING " + (this.having.toSQL());
      } else {
        return grouping.join(", ");
      }
    };

    return Group;

  })(Node);

  Having = (function(superClass) {
    extend(Having, superClass);

    function Having(exprs1) {
      this.exprs = exprs1 != null ? exprs1 : [];
      this.exprs = _.compact(_.flatten([this.exprs]));
      Having.__super__.constructor.apply(this, arguments);
    }

    Having.prototype.children = function() {
      return this.exprs;
    };

    Having.prototype.clone = function() {
      var exprs;
      exprs = _.map(this.exprs, function(e) {
        return e.clone();
      });
      return new Having(exprs);
    };

    Having.prototype.toSQL = function() {
      return _.map(this.exprs, function(e) {
        return e.toSQL();
      }).join(", ");
    };

    return Having;

  })(Node);

  OrderBy = (function(superClass) {
    extend(OrderBy, superClass);

    function OrderBy(exprs1) {
      this.exprs = exprs1 != null ? exprs1 : [];
      this.exprs = _.compact(_.flatten([this.exprs]));
      OrderBy.__super__.constructor.apply(this, arguments);
    }

    OrderBy.prototype.children = function() {
      return this.exprs;
    };

    OrderBy.prototype.clone = function() {
      return new OrderBy(this.exprs.map(function(e) {
        return e.clone();
      }));
    };

    OrderBy.prototype.toSQL = function() {
      return this.exprs.map(function(e) {
        return e.toSQL();
      }).join(", ");
    };

    return OrderBy;

  })(Node);

  OrderByClause = (function(superClass) {
    extend(OrderByClause, superClass);

    function OrderByClause(expr1, asc1) {
      this.expr = expr1;
      this.asc = asc1 != null ? asc1 : true;
      OrderByClause.__super__.constructor.apply(this, arguments);
    }

    OrderByClause.prototype.clone = function() {
      return new OrderByClause(this.expr.clone(), this.asc);
    };

    OrderByClause.prototype.children = function() {
      return [this.expr];
    };

    OrderByClause.prototype.toSQL = function() {
      var asc;
      asc = this.asc ? "ASC" : "DESC";
      return (this.expr.toSQL()) + " " + asc;
    };

    return OrderByClause;

  })(Node);

  Limit = (function(superClass) {
    extend(Limit, superClass);

    function Limit(expr1, offset1) {
      this.expr = expr1;
      this.offset = offset1;
      Limit.__super__.constructor.apply(this, arguments);
    }

    Limit.prototype.clone = function() {
      var offset;
      offset = null;
      if (this.offset != null) {
        offset = this.offset.clone();
      }
      return new Limit(this.limit.clone(), offset);
    };

    Limit.prototype.children = function() {
      return _.compact([this.expr, this.offset]);
    };

    Limit.prototype.toSQL = function() {
      if (this.offset != null) {
        return (this.expr.toSQL()) + " OFFSET " + (this.offset.toSQL());
      } else {
        return this.expr.toSQL();
      }
    };

    return Limit;

  })(Expr);

  FunctionQuery = (function(superClass) {
    extend(FunctionQuery, superClass);

    function FunctionQuery(fname, tableOrQuery) {
      this.fname = fname;
      this.tableOrQuery = tableOrQuery;
      FunctionQuery.__super__.constructor.apply(this, arguments);
      if (this.tableOrQuery == null) {
        throw new Error("FunctionQuery cannot have empty argument");
      }
    }

    FunctionQuery.prototype.clone = function() {
      return new FunctionQuery(this.fname, this.tableOrQuery.clone());
    };

    FunctionQuery.prototype.children = function() {
      return [this.tableOrQuery];
    };

    FunctionQuery.prototype.toSQL = function() {
      return this.fname + "(" + (this.tableOrQuery.toSQL()) + ")";
    };

    return FunctionQuery;

  })(Node);

  schema = (function() {
    var get_schema;
    return get_schema = function(queryName, nameToQueries, seen) {
      var i, isConsistent, len, query, rest, sources, star, starSchema, starSchemas, stars, tmp;
      if (seen == null) {
        seen = {};
      }
      if (queryName in seen) {
        return [];
      }
      seen[queryName] = true;
      query = nameToQueries[queryName];
      schema = query.schema();
      stars = _.filter(schema, function(s) {
        return s.type === "star";
      });
      rest = _.reject(schema, function(s) {
        return s.type === "star";
      });
      if (!stars.length) {
        return rest;
      }
      starSchemas = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = stars.length; i < len; i++) {
          star = stars[i];
          if (star.table != null) {
            results.push(get_schema(star.table.name, nameToQueries, seen));
          } else {
            sources = query.sources();
            if (sources.length !== 1) {
              throw new Error("* project clause must be qualified with table name if >1 table source");
            }
            results.push(get_schema(sources[0].name, nameToQueries, seen));
          }
        }
        return results;
      })();
      tmp = null;
      for (i = 0, len = starSchemas.length; i < len; i++) {
        starSchema = starSchemas[i];
        if (tmp == null) {
          tmp = starSchema;
        }
        isConsistent = _.chain(tmp).zip(starSchema).all(function(p) {
          return p[0].type === p[1].type;
        }).value();
        if (!isConsistent) {
          throw new Error("Inconsistent schemas: " + (JSON.stringify(tmp)) + " ::: " + (JSON.stringify(starSchema)));
        }
      }
      return rest.concat(tmp);
    };
  })();

  module.exports = {
    Queries: Queries,
    SelectCore: SelectCore,
    Query: Query,
    Project: Project,
    ProjectClause: ProjectClause,
    From: From,
    Table: Table,
    ExternalTable: ExternalTable,
    QueryTable: QueryTable,
    Where: Where,
    Expr: Expr,
    SpecialExpr: SpecialExpr,
    BetweenExpr: BetweenExpr,
    UnaryExpr: UnaryExpr,
    QuantExpr: QuantExpr,
    FuncExpr: FuncExpr,
    ColExpr: ColExpr,
    TableExpr: TableExpr,
    ValExpr: ValExpr,
    Group: Group,
    Having: Having,
    OrderBy: OrderBy,
    OrderByClause: OrderByClause,
    Limit: Limit,
    FunctionQuery: FunctionQuery,
    schema: schema
  };

}).call(this);
